% !TeX root = ../my-thesis.tex
\chapter{Verwendete Geräte und Tools}
\section{Vorstellung der Test-App für diese Arbeit}
Im Rahmen dieser Arbeit wurde die \glqq EnergyEfficience\grqq{} App entwickelt. In dieser App wurden verschiedene Implementierungen von Algorithmen umgesetzt, mit deren Hilfe Laufzeit- und Energieeffizienz dieser Berechnungen gemessen werden kann.
Die \glqq EnergyEfficience\grqq{} App wurde auf Basis des Android \ac{sdk} 30 entwickelt, welche die zum Zeitpunkt der Erstellung dieser Arbeit die aktuellste Android API ist und somit für Android 11 empfohlen wird. Für die Programmierung selbst wurde ausschließlich mit Java gearbeitet. Allerdings ist Kotlin mittlerweile die empfohlene Programmiersprache für die Androidentwicklung, da die Bereitstellung der neuen \ac{sdk}'s und der Android Support Bibliotheken immer stärker auf das Motto \glqq Kotlin-first\grqq{} \cite{kotlin-first} ausgerichtet wird. Inwiefern die Java Unterstützung für zukünftige \ac{sdk} Versionen bestehen bleibt, ist zum aktuellen Zeitpunkt nicht absehbar.
Für die persistente Speicherung von beispielsweise Testdaten und Nutzereinstellungen wurde die Room Persistence Library in der Version 2.2.5 genutzt.
\begin{figure}[H]
	\begin{center}	 
	\includegraphics[scale=0.5]{base64Pic}
	\caption{MainActivity der EnergyEfficience App (eigene Abbildung)}
	\label{fig:MainActivity} 
	\end{center}
\end{figure}
In \autoref{fig:MainActivity} ist das \ac{ui} der Launch Activity der App zu sehen. Über ein dreiteiliges Tab Layout Menü sind drei verschiedene Fragmente erreichbar, welche jeweils einen Algorithmus thematisieren. Die Fragmente sind über einen View Pager und einen Fragment State Adapter mit dem Tab Layout gekoppelt. Das Base64 Fragment implementiert einen einfachen Base64 Encoder. Über die Schaltfläche \glqq ENCODE SHOWCASE\grqq{} wird der Text aus dem darüber gelegenen Eingabefeld in das entsprechende Base64-Format kodiert und in der rechts angrenzenden TextView ausgegeben. Die für die Messung relevanten Berechnungen lassen sich über den \glqq ENCODE ASYNCH\grqq{} Button starten. Bevor dies geschieht, sollte in das links darüber gelegene Textfeld die Größe des zu kodierenden Strings angeben werden. Dabei ist die Einheit \ac{kb} und es sollte darauf geachtet werden, dass aus Gründen der internen Implementierung die Mindestgröße von 10000 \ac{kb} nicht unterschritten wird. 
Über das rechts daneben platzierte Textfeld lässt sich die Anzahl der Threads festlegen, die zur parallelen Ausführung der Kodierung angewandt werden soll. Die detaillierte Implementierung dieser Parallelität mithilfe eines Threadpools wurde bereits in \autoref{lst:CustomThreadManager} aus Kapitel 2 beschrieben. Während der Laufzeit der Kodierung erscheint eine rot unterlegte \glqq in progress\grqq{} Meldung, welche nach Terminierung wieder verschwindet. Die Laufzeitdaten und Parameter des Durchlaufs werden anschließend in blau gestalteten Textboxen innerhalb einer scrollbaren Recycler View dargestellt. Mithilfe des roten Kreuzes kann diese Recycler View wieder geleert werden.
\begin{figure}[H]
\begin{center}
	\includegraphics[scale=0.5]{ASternPic}
	\caption{A*-Path finding Fragment (eigene Abbildung)}
	\label{fig:Pathfinding} 
\end{center}
\end{figure}
Im A*-Path finding Fragment wurde eine Implementierung des A*-Pathfinding Algorithmus umgesetzt. Die \ac{ui} ist in \autoref{fig:Pathfinding} zu sehen. Über die Schaltfläche \glqq GENERATE MAP\grqq{} wird eine zweidimensionale Rasterkarte mit zufällig generierten Start- und Endpunkten einer Route und beliebig vielen Hindernissen erstellt. Hierbei werden Hindernisse durch schwarze Kacheln dargestellt. Nach Betätigung der \glqq FIND PATH\grqq{} Schaltfläche wird, falls vorhanden, der kürzeste Weg zwischen Start- und Endpunkt ermittelt und anhand einer grünen Markierung gekennzeichnet.

In \autoref{fig:MergeSort} ist auf der linken Seite das Mergesort Fragment zu sehen, welches zur Veranschaulichung der verschiedenen Merge Sort Varianten dient und auf der rechten Seite die Mergesort Activty, welche zwar keine visuelle Darstellung der sortierten Daten enthält, dafür aber die Möglichkeit bietet, beliebig lang andauernde Sortierungen durchzuführen. Für die Durchführung der Messungen ist daher diese Activity vorgesehen.
\begin{figure}[H]
\begin{center}
	\includegraphics[scale=0.5]{MergeSort}
	\caption{MergeSort Fragment und Activity zur Messung (eigene Abbildung)}
	\label{fig:MergeSort} 
\end{center}
\end{figure}
Über das Textfeld kann eine beliebige Anzahl von Nummern festgelegt werden, welche durch den Algorithmus sortiert werden soll. Es wird empfohlen, dabei die Obergrenze von  \ac{mio} nicht zu überschreiten, da es bei der Allokation von Arbeitsspeicher für Datenstrukturen wie Arrays oder Listen mit so vielen Elementen zu Out of Memory Erros kommen kann. Diese führen unweigerlich zum Absturz der Applikation. Durch betätigen der \glqq GENERATE NUMBERS\grqq{} Schaltfläche werden dieser Anzahl entsprechend viele Zufallszahlen zwischen 0 und 9000000 in zufälliger Reihenfolge generiert und Recycler View dargestellt. Dabei gibt der blau hinterlegte Index die Position der Zahl im internen Array an. Über die vier Radio Buttons kann zwischen verschiedenen Sortierverfahren gewählt werden. Für die Untersuchung im Rahmen dieser Arbeit sind der klassische, rekursive Mergesort, der iterative Mergesort und der parallele Mergesort relevant. Über die \glqq MERGE SORT\grqq{} Schaltfläche kann die Sortierung gestartet werden. Auch hier wird nach Terminierung der Berechnung die Laufzeit in \ac{ms} ausgegeben. Die Elemente in der Recycle View werden anschließend der neuen Sortierung entsprechend aktualisiert. Die Einschränkung durch den vergleichsweise geringen Arbeitsspeicher auf mobilien Geräten verhindert die Generierung von ausreichend vielen Testdaten um eine für Messungen günstige Laufzeit zu erreichen. Daher wurde eine weitere Activity erstellt, um dieses Problem für längere Messungen zu umgehen. Auf der rechten Seite von \autoref{fig:MergeSort} ist zu erkennen, dass das \ac{ui} bis auf das Fehlen der Recycler View einen ähnlichen Aufbau wie das Mergesort Fragment besitzt. Hierbei ist jedoch zu Beachten, dass über das Textfeld nicht die Anzahl der Elemente eingestellt wird, sondern die Anzahl der Iterationen einer Sortierung. In jeder Iteration werden 3 \ac{mio} Zahlen sortiert. Dieses Vorgehen verhindert die gleichzeitige Allokation von zu viel Heap Speicher und somit Out of Memory Errors und gewährleistet außerdem eine beliebig andauernde Laufzeit für die Messung. Des weiteren bleiben die Testdaten im Gegensatz zum Mergesort Fragment konstant, da 3 \ac{mio} Zahlen mithilfe einer Room Database persistent gespeichert werden. Über die Schaltfläche \glqq GENERATE NEW NUMBERS\grqq{} können 3 \ac{mio} neue Zufallszahlen zwischen 0 und 9 \ac{mio} generiert und in die Datenbank gespeichert werden. Über das blaue, kreisförmige Icon des Mergesort Fragments, ist diese Activty zu erreichen. Bei der Nutzung dieser Activity ist zu beachten, dass das die erstmalige Betätigen der glqq MERGE SORT\grqq{} Schaltfläche nach Anwendungsstart zu einer kurzen Wartezeit führt, da zunächst die Daten aus der Datenbank geladen werden. Diese initiale Ladezeit ist natürlich aus der Zeitmessung ausgeschlossen.

\section{Gerätespezifikationen und Battery Historian zur Messdatenermittlung}

Als Testgerät wurde das Samsung Galaxy A7 aus dem Jahr 2018 gewählt. Es besitzt 64 \ac{gb} Festplattenspeicher und vier \ac{gb} Arbeitsspeicher. Der Akku besitzt eine Kapazität von 3300 \ac{mAh}. Bei dem sechs Zoll großen Display handelt es ich um einen Super-AMOLED mit einer Auflösung von 1080 x 2220 Pixel bei einer Pixeldichte von 411 \ac{ppi} \cite{smartphone-data}. Die \ac{cpu} ist ein Achtkernsystem mit der Architektur eines Exynos 7885 \ac{soc} von Samsung.  Diese Architektur besteht zum einen aus zwei schnellen Cortex-A73 Rechenkernen mit 2,20 \ac{ghz} und zum anderen aus sechs stromsparenden Cortex-A53 Kernen mit jeweils 1,6 \ac{ghz} Taktfrequenz. Exynos ist eine \ac{soc} Familie, deren Mikroprozessorkomponenten auf der ARM-Architektur basieren. Diese Architektur zeichnet sich durch einen effizienten Befehlssatz aus, der eine kompakte Implementierung im \ac{ascii}-Design erlaubt und daher für Optimierungen im Bereich des Energiesparens sehr gut geeignet ist. Dieses Design wurde ursprünglich vom britischen Unternehmen ARM entwickelt. Große Unternehmen wie Apple, Huawei, Qualcomm oder Samsung besitzen Lizenzen für diese Architektur und können daher hauseigene Lösungen mit dieser Technik für ihre Geräte entwickeln \cite{cpu-data}. Die mit dieser Architektur einhergehende Besonderheit, dass Kerne aus zwei verschiedenen Leistungsklassen verbaut werden, spiegelt sich auch in den Messergebnissen der Untersuchung in Kapitel 4 \glqq Energieeffizientes Multithreading\grqq{} wieder.

Zur Messung des Strom- und Spannungsverlaufs des Akkus während der Ausführung der Berechnungen wurde das Programm Battery Historian in der Version 3.0 genutzt. Um dieses Tool nutzen zu können, ist eine aktuelle Docker Umgebung nötig. 

Im Rahmen dieser Arbeit wurde die Version v19.03.12 genutzt. Bei Docker handelt es sich um eine Anwendung zur Erstellung und Verwaltung von sogenannten Linux Containern. Dies ermöglicht eine komfortable und schnelle Installation und Skalierung von Software jeglicher Art. Sofern eine Installation der Docker Engine vorhanden ist, lassen sich so neue Softwareinstanzen eines beliebigen Programms unabhängig vom installierten Betriebssystem und vorhanden Bibliotheken mit wenig Installationsaufwand aufsetzen. Alle Voraussetzungen und nötigen Konfigurationen für das Aufsetzen der gewünschten Software oder Anwendungsinstanz werden hierbei durch ein Docker Image vorgegeben und müssen nicht mehr manuell umgesetzt werden. Virtuelle Maschinen liefern zwar einen ähnlichen Komfort, sind jedoch vergleichsweise ressourcenaufwendig, da Hier ganze Betriebssysteme mit hohem Speicherbedarf installiert werden. Die Docker Engine hingegen ermöglicht einen direkte Zugriff auf den Kernel des Host-Betriebssystems und spart somit Speicher und ist wesentlich schneller in der Ausführung als eine herkömmliche virtuelle Maschine \cite{Docker}.  In Verbindung mit zusätzlichen Tools wie Kubernetes, kann die Skalierung und Verwaltung der Docker Container und somit auch der eigenen Softwareinstanzen fast vollständig automatisiert werden \cite{Kubernetes}.

Soblad das aktuelle Docker Image von Battery Historian läuft, ist es möglich, die von Android gesammelten Logdateien bezüglich des Batteriestatus in einer \ac{html} Visualisierung darzustellen. Informationen über den Energieverbrauch und Statistiken über die Nutzung von sämtlichen Hardwarekomponenten des Gerätes werden permanent im Hintergrund gesammelt. Hierzu wird unter anderem das Tool Batterystats genutz, welches in das Android Framework integriert ist \cite{batteryhistorianandroid}. Mithilfe der \ac{adb} \footnote{die \ac{adb} ist ein Schnittstellen Programm zwischen Computer und Androidgerät zur Ausführung von Befehlen und zur Übertragung von Dateien} ist es möglich, diese Logdaten in ein ZIP-Dateiformat zu komprimieren und auf ein anderes Gerät zu laden. Hierfür wird der Befehl \emph{adb bugreport bugreport.zip} genutzt \cite{batteryhistorian}. 

In Abbildung \ref{fig:Voltage} ist die grafische Darstellung dieser Logdateien zu sehen. Die horizontal verlaufenden farbigen Balken kennzeichnen die Aktivität verschiedener Komponenten des Smartphones, welche zum jeweiligen Zeitpunkt Strom verbrauchen. So lassen sich \ac{cpu} Aktivitäten, Wakelocks oder \ac{wifi} Aktivitäten nachvollziehen. Für netzwerkspezfische Datensätze wie \glqq Mobile signal strength\grqq{} oder \glqq Wifi signal strength\grqq{} nimmt der Balken in Abhängigkeit der Signalstärke verschiedene Farben an. So steht grün für optimale Signalstärke und rot für eine schlechte Verbindung. Sehr nützlich für die Untersuchung sind vor allem die Informationen zur aktuellen Betriebstemperatur des Chips und die Anzeige von benutzerimplizierten Wakelocks. Die Betriebstemperatur ist ein signifikanter Faktor, der die Leistungsfähigkeit der \ac{cpu} beeinflusst und daher während der Messungen möglichst konstant gehalten werden muss, um vergleichbare Ergebnisse zu erhalten. Bei vielen Geräte wird bei zu hoher Betriebstemperatur die Taktrate des Systems verringert, um die eine Überhitzung zu vermeiden und die Lebensdauer der Chips zu verlängern.

Über ein Dropdown-Menü rechts oberhalb des Diagramms lassen sich verschiedene Graphen Anzeigen. In \autoref{fig:Voltage} ist der Voltage Graph zu sehen, welcher den Spannungsverlauf in \ac{mV} über der Ziet darstellt. Das Tool zeichnet Messwerte im Intervall von 30 Sekunden auf. Daher sind relativ lang andauernde Messungen über mehrere Minuten notwendig, um sinnvolle Wertereihen zu erhalten. Die Spannung wird für jedes 30 Sekundenintervall als Spannungsbereich mit Ober- und Untergrenze angegeben. In \autoref{fig:Voltage} ist beispielsweise ein Messpunk ausgewählt mit einer Spannung, die im aktuellen 30 Sekundenintervall zwischen 4127 \ac{mV} und 3986 \ac{mV} liegt. Für die Berechnungen im Kontext der Untersuchung dieser Arbeit wurden stets die Mittelwerte dieser Spannungsbereiche ermittelt und genutzt. Um Werte für die Stromstärke in Abhängigkeit von der Zeit einsehen zu können, muss entweder der Graph \emph{Battery Level} oder \emph{Coulomb charge} genutzt werden. Auch hier werden die Werte in Intervallen von 30 Sekunden angezeigt. Allerdings wird hier ein genauer Wert in \ac{mA} angegeben, welcher neben dem Wert für den aktuellen Füllstand des Akkus in \ac{mAh} als \glqq Charge rate\grqq{} abzulesen ist. Mithilfe der beiden Graphen für den Spannungs- und Entladestromverlauf kann die elektrische Leistung über der Zeit abgebildet werden. Anschließend kann durch Integration dieses Graphen der Energieverbrauch insgesamt als verrichtete elektrische Arbeit ermittelt werden. Dieses Vorgehen wird in den folgenden Kapiteln mit der Anwendung auf die Messwerte näher beschrieben. Alle Messungen wurden unter möglichst identischen Grundvoraussetzungen durchgeführt. Es wurde stets das gleiche Gerät verwendet. Jede Messung wurde mit identischen Akkufüllstand gestartet. Außerdem wurde darauf geachtet, dass während den Messungen keine Netzwerkverbindungen aktiv waren. Einstellungen wie Bildschirmhelligkeit oder Betriebsmodus wurden nicht variiert. Im Zeitraum der Untersuchung wurden außerdem keine Updates des Betriebssystems zugelassen um eine möglichst konstante Laufzeitumgebung zu gewährleisten.

\begin{figure}
\begin{center}
	\includegraphics[scale=0.3]{Voltage}
	\caption{Battery Historian Benutzeroberfläche mit Spannungsverlauf \glqq Voltage\grqq{} (eigene Abbildung)}
	\label{fig:Voltage} 
\end{center}
\end{figure}
